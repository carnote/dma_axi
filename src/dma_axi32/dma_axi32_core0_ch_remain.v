//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_remain.v
//---------------------------------------------------------



module dma_axi32_core0_ch_remain(clk,reset,ch_update,wr_outstanding,rd_outstanding,load_req_in_prog,rd_line_cmd,rd_burst_start,rd_burst_size,rd_transfer,rd_transfer_size,wr_clr_line,wr_burst_start,wr_burst_size,wr_transfer,wr_transfer_size,rd_gap,wr_fullness);

   input                    clk;
   input             reset;

   input             ch_update;
   input             wr_outstanding;
   input             rd_outstanding;
   input             load_req_in_prog;
   
   input             rd_line_cmd;
   input             rd_burst_start; 
   input [7-1:0]   rd_burst_size; 
   input             rd_transfer;
   input [3-1:0]    rd_transfer_size;
   
   input             wr_clr_line;
   input             wr_burst_start;
   input [7-1:0]   wr_burst_size;  
   input             wr_transfer;
   input [3-1:0]    wr_transfer_size;
   
   output [5:0]     rd_gap;
   output [5:0]     wr_fullness; 
   


   wire             rd_line_cmd_valid;
   reg [5+1:0]         rd_gap_reg; //signed
   reg [5+1:0]         wr_fullness_reg; //signed

   wire             rd_burst_qual;
   wire             wr_burst_qual;
   reg [7-1:0]     rd_burst_size_valid; 
   wire [3-1:0]     rd_transfer_size_valid;
   wire [3-1:0]     wr_transfer_size_valid;
   reg [7-1:0]     wr_burst_size_valid; 



   
   assign             rd_line_cmd_valid = rd_line_cmd & rd_burst_start;
   
   assign             rd_burst_qual = rd_burst_start & (~load_req_in_prog);
   assign             wr_burst_qual = wr_burst_start;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_burst_size_valid <= #1 {7{1'b0}};
     else if (rd_burst_qual)
       rd_burst_size_valid <= #1 rd_burst_size;
     else
       rd_burst_size_valid <= #1 {7{1'b0}};
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_burst_size_valid <= #1 {7{1'b0}};
     else if (wr_burst_qual)
       wr_burst_size_valid <= #1 wr_burst_size;
     else
       wr_burst_size_valid <= #1 {7{1'b0}};
   
   assign             rd_transfer_size_valid = {3{rd_transfer}} & rd_transfer_size;
   assign             wr_transfer_size_valid = {3{wr_transfer}} & wr_transfer_size;
   
   
   //for rd bursts
   always @(posedge clk or posedge reset)
     if (reset)
       rd_gap_reg <= #1 {1'b0, 1'b1, {5{1'b0}}};
     else if (ch_update)
       rd_gap_reg <= #1 {1'b0, 1'b1, {5{1'b0}}};
     else
       rd_gap_reg <= #1 rd_gap_reg - 
             rd_burst_size_valid +
             wr_transfer_size_valid;
   
   
   assign rd_gap = rd_gap_reg[5+1] ? 'd0 : rd_gap_reg[5:0];

   
   //for wr bursts
   always @(posedge clk or posedge reset)
     if (reset)
       wr_fullness_reg <= #1 {5+1{1'b0}};
     else if (ch_update)
       wr_fullness_reg <= #1 {5+1{1'b0}};
     else
       wr_fullness_reg <= #1 wr_fullness_reg -
              wr_burst_size_valid +
              rd_transfer_size_valid; 

   
   assign wr_fullness = wr_fullness_reg[5+1] ? 'd0 : wr_fullness_reg[5:0];
   
endmodule





