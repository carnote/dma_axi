//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:36:56 2011
//--
//-- Source file: dma_ch_reg_size.v
//---------------------------------------------------------


  
module dma_axi64_core0_ch_reg_size(clk,reset,update,start_addr,burst_max_size_reg,burst_max_size_other,allow_full_burst,allow_full_fifo,joint_flush,burst_max_size);

   parameter              MAX_BURST     = 0 ? 64 : 128; //16 strobes
   parameter              HALF_BYTES    = 32/2;
   parameter              LARGE_FIFO    = 32 > MAX_BURST;
   parameter              SMALL_FIFO    = 32 == 16;
   
   input                  clk;
   input              reset;

   input              update;

   input [32-1:0]      start_addr;
   input [8-1:0]      burst_max_size_reg;
   input [8-1:0]      burst_max_size_other;

   input              allow_full_burst;
   input              allow_full_fifo;
   input              joint_flush;
   output [8-1:0]      burst_max_size;

   
   
   wire [8-1:0]      burst_max_size_fifo;
   wire [8-1:0]      burst_max_size_pre;
   reg [8-1:0]      burst_max_size;

   
  
   
   assign              burst_max_size_fifo = 
                 allow_full_burst | LARGE_FIFO ? MAX_BURST  :
                 joint_flush & SMALL_FIFO      ? HALF_BYTES :
                 (burst_max_size_other > HALF_BYTES) & (burst_max_size_reg > HALF_BYTES) & (burst_max_size_other != burst_max_size_reg) 
                                                               ? HALF_BYTES :
                 allow_full_fifo               ? 32 : HALF_BYTES;
   
   
   prgen_min2 #(8) min2_max(
                   .a(burst_max_size_reg),
                   .b(burst_max_size_fifo),
                   .min(burst_max_size_pre)
                   );
   
   always @(posedge clk or posedge reset)
     if (reset)
       burst_max_size <= #1 {8{1'b0}};
     else if (update)
       burst_max_size <= #1 burst_max_size_pre > MAX_BURST ? MAX_BURST : burst_max_size_pre;

   
endmodule


